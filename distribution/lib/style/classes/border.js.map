{"version":3,"sources":["../../../../source/lib/style/classes/border.js"],"names":["utils","require","types","_","xmlbuilder","CTColor","BorderOrdinal","opts","color","undefined","style","borderStyle","validate","obj","toObject","Border","left","right","top","bottom","diagonal","outline","diagonalDown","diagonalUp","Object","keys","forEach","opt","indexOf","TypeError","borderXML","bXML","ele","att","ord","thisOEle","addToXMLele","module","exports"],"mappings":"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","file":"border.js","sourcesContent":["const utils = require('../../utils.js');\nconst types = require('../../types/index.js');\nconst _ = require('lodash');\nconst xmlbuilder = require('xmlbuilder');\nconst CTColor = require('./ctColor.js');\n\nclass BorderOrdinal {\n    constructor(opts) {\n        opts = opts ? opts : {};\n        if (opts.color !== undefined) {\n            this.color = new CTColor(opts.color);\n        }\n        if (opts.style !== undefined) {\n            this.style = types.borderStyle.validate(opts.style) === true ? opts.style : null;\n        }\n    }\n\n    toObject() {\n        let obj = {};\n        if (this.color !== undefined) {\n            obj.color = this.color.toObject();\n        }\n        if (this.style !== undefined) {\n            obj.style = this.style;\n        }\n        return obj;\n    }\n}\n\nclass Border {\n    /** \n     * @class Border\n     * @desc Border object for Style\n     * @param {Object} opts Options for Border object\n     * @param {Object} opts.left Options for left side of Border\n     * @param {String} opts.left.color HEX represenation of color\n     * @param {String} opts.left.style Border style\n     * @param {Object} opts.right Options for right side of Border\n     * @param {String} opts.right.color HEX represenation of color\n     * @param {String} opts.right.style Border style\n     * @param {Object} opts.top Options for top side of Border\n     * @param {String} opts.top.color HEX represenation of color\n     * @param {String} opts.top.style Border style\n     * @param {Object} opts.bottom Options for bottom side of Border\n     * @param {String} opts.bottom.color HEX represenation of color\n     * @param {String} opts.bottom.style Border style\n     * @param {Object} opts.diagonal Options for diagonal side of Border\n     * @param {String} opts.diagonal.color HEX represenation of color\n     * @param {String} opts.diagonal.style Border style\n     * @param {Boolean} opts.outline States whether borders should be applied only to the outside borders of a cell range\n     * @param {Boolean} opts.diagonalDown States whether diagonal border should go from top left to bottom right\n     * @param {Boolean} opts.diagonalUp States whether diagonal border should go from bottom left to top right\n     * @returns {Border}\n     */\n    constructor(opts) {\n        opts = opts ? opts : {};\n        this.left;\n        this.right;\n        this.top;\n        this.bottom;\n        this.diagonal;\n        this.outline;\n        this.diagonalDown;\n        this.diagonalUp;\n\n        Object.keys(opts).forEach((opt) => {\n            if (['outline', 'diagonalDown', 'diagonalUp'].indexOf(opt) >= 0) {\n                if (typeof opts[opt] === 'boolean') {\n                    this[opt] = opts[opt];\n                } else {\n                    throw new TypeError('Border outline option must be of type Boolean');\n                }\n            } else if (['left', 'right', 'top', 'bottom', 'diagonal'].indexOf(opt) < 0) {  //TODO: move logic to types folder\n                throw new TypeError(`Invalid key for border declaration ${opt}. Must be one of left, right, top, bottom, diagonal`);\n            } else {\n                this[opt] = new BorderOrdinal(opts[opt]);\n            }\n        });\n    }\n\n    /** \n     * @func Border.toObject\n     * @desc Converts the Border instance to a javascript object\n     * @returns {Object}\n     */\n    toObject() {\n        let obj = {};\n        obj.left;\n        obj.right;\n        obj.top;\n        obj.bottom;\n        obj.diagonal;\n\n        if (this.left !== undefined) {\n            obj.left = this.left.toObject();\n        }\n        if (this.right !== undefined) {\n            obj.right = this.right.toObject();\n        }\n        if (this.top !== undefined) {\n            obj.top = this.top.toObject();\n        }\n        if (this.bottom !== undefined) {\n            obj.bottom = this.bottom.toObject();\n        }\n        if (this.diagonal !== undefined) {\n            obj.diagonal = this.diagonal.toObject();\n        }\n        typeof this.outline === 'boolean' ? obj.outline = this.outline : null;\n        typeof this.diagonalDown === 'boolean' ? obj.diagonalDown = this.diagonalDown : null;\n        typeof this.diagonalUp === 'boolean' ? obj.diagonalUp = this.diagonalUp : null;\n\n        return obj;\n    }\n\n    /**\n     * @alias Border.addToXMLele\n     * @desc When generating Workbook output, attaches style to the styles xml file\n     * @func Border.addToXMLele\n     * @param {xmlbuilder.Element} ele Element object of the xmlbuilder module\n     */\n    addToXMLele(borderXML) {\n        let bXML = borderXML.ele('border');\n        if (this.outline === true) {\n            bXML.att('outline', '1');\n        }\n        if (this.diagonalUp === true) {\n            bXML.att('diagonalUp', '1');\n        }\n        if (this.diagonalDown === true) {\n            bXML.att('diagonalDown', '1');\n        }\n\n        ['left', 'right', 'top', 'bottom', 'diagonal'].forEach((ord) => {\n            let thisOEle = bXML.ele(ord);\n            if (this[ord] !== undefined) {\n                if (this[ord].style !== undefined) {\n                    thisOEle.att('style', this[ord].style);\n                }\n                if (this[ord].color instanceof CTColor) {\n                    this[ord].color.addToXMLele(thisOEle);\n                }\n            }\n        });\n    }\n}\n\nmodule.exports = Border;"]}